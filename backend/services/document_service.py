#!/usr/bin/env python3
"""
Document Service
================

Service for handling document operations, exports, and versioning.
"""

import logging
import uuid
import json
import os
from datetime import datetime
from typing import Dict, Any, Optional, List
from ..models.database import PetitionRepository

logger = logging.getLogger(__name__)

class DocumentService:
    def __init__(self, base_path: str = "static/documents"):
        self.base_path = base_path
        self._ensure_directories()
        
    def _ensure_directories(self):
        """Ensure document directories exist"""
        os.makedirs(self.base_path, exist_ok=True)
        os.makedirs("static", exist_ok=True)
        
    async def export_document(self, petition_id: str, format_type: str, session_id: str) -> Optional[Dict[str, Any]]:
        """Export a petition in the specified format"""
        try:
            logger.info(f"📄 Exporting petition {petition_id} in {format_type} format")
            
            # Get petition data
            petition = await PetitionRepository.get_petition(petition_id)
            if not petition:
                logger.error(f"❌ Petition not found: {petition_id}")
                return None
            
            # Generate document
            document_id = str(uuid.uuid4())
            file_path = await self._generate_document_file(
                petition, format_type, document_id
            )
            
            if not file_path:
                logger.error("❌ Failed to generate document file")
                return None
            
            # Create download URL
            download_url = f"/static/documents/{os.path.basename(file_path)}"
            
            return {
                'document_id': document_id,
                'file_path': file_path,
                'download_url': download_url,
                'generated_at': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"❌ Error exporting document: {e}")
            return None
    
    async def _generate_document_file(self, petition: Dict[str, Any], format_type: str, document_id: str) -> Optional[str]:
        """Generate document file in specified format"""
        try:
            case_details = petition['case_details']
            petition_text = petition['petition_text']
            
            if format_type == "json":
                return await self._generate_json_file(petition, document_id)
            elif format_type == "txt":
                return await self._generate_text_file(petition, document_id)
            elif format_type == "pdf":
                return await self._generate_pdf_file(petition, document_id)
            else:
                logger.error(f"❌ Unsupported format: {format_type}")
                return None
                
        except Exception as e:
            logger.error(f"❌ Error generating document file: {e}")
            return None
    
    async def _generate_json_file(self, petition: Dict[str, Any], document_id: str) -> str:
        """Generate JSON document file"""
        file_path = os.path.join(self.base_path, f"{document_id}.json")
        
        document_data = {
            'document_id': document_id,
            'petition_id': petition.get('petition_id'),
            'generated_at': datetime.now().isoformat(),
            'format': 'json',
            'case_details': petition['case_details'],
            'petition_text': petition['petition_text'],
            'metadata': {
                'version': petition.get('version_number', 1),
                'session_id': petition.get('session_id'),
                'status': petition.get('status', 'generated')
            }
        }
        
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(document_data, f, ensure_ascii=False, indent=2)
        
        return file_path
    
    async def _generate_text_file(self, petition: Dict[str, Any], document_id: str) -> str:
        """Generate text document file"""
        file_path = os.path.join(self.base_path, f"{document_id}.txt")
        
        case_details = petition['case_details']
        
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write("LEGAL PETITION GENERATED BY PETITION AUTOMATOR\n")
            f.write("=" * 60 + "\n\n")
            f.write(f"Case Type: {case_details.get('case_type', 'Unknown')}\n")
            f.write(f"Court: {case_details.get('court', 'Unknown')}\n")
            f.write(f"Petitioner: {case_details.get('petitioner_name', 'Unknown')}\n")
            f.write(f"Respondent: {case_details.get('respondent_name', 'Unknown')}\n")
            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write("=" * 60 + "\n\n")
            f.write(petition['petition_text'])
        
        return file_path
    
    async def _generate_pdf_file(self, petition: Dict[str, Any], document_id: str) -> str:
        """Generate PDF document file (placeholder)"""
        # For now, generate a text file with .pdf extension
        # In production, you'd use a library like reportlab or weasyprint
        file_path = os.path.join(self.base_path, f"{document_id}.pdf")
        
        # Create a simple text-based PDF placeholder
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write("PDF generation would be implemented here\n")
            f.write("Using libraries like reportlab or weasyprint\n")
            f.write(f"Petition ID: {petition.get('petition_id')}\n")
            f.write(f"Generated: {datetime.now().isoformat()}\n")
        
        return file_path
    
    async def get_document_versions(self, petition_id: str) -> List[Dict[str, Any]]:
        """Get all versions of a document"""
        try:
            logger.info(f"📜 Getting versions for petition: {petition_id}")
            
            # This would query the database for document versions
            # For now, return placeholder data
            return [
                {
                    'version_id': f"{petition_id}_v1",
                    'version_number': 1,
                    'created_at': datetime.now().isoformat(),
                    'changes_made': 'Initial version'
                }
            ]
            
        except Exception as e:
            logger.error(f"❌ Error getting document versions: {e}")
            return []
    
    async def get_specific_version(self, petition_id: str, version_number: int) -> Optional[Dict[str, Any]]:
        """Get a specific version of a document"""
        try:
            logger.info(f"📄 Getting version {version_number} of petition: {petition_id}")
            
            # This would query the database for specific version
            # For now, return placeholder data
            return {
                'version_id': f"{petition_id}_v{version_number}",
                'version_number': version_number,
                'created_at': datetime.now().isoformat(),
                'changes_made': f'Version {version_number}',
                'document_url': f'/static/documents/{petition_id}_v{version_number}.txt'
            }
            
        except Exception as e:
            logger.error(f"❌ Error getting specific version: {e}")
            return None
    
    async def get_document_file_path(self, document_id: str) -> Optional[str]:
        """Get file path for a document"""
        try:
            # Look for files with this document ID
            for filename in os.listdir(self.base_path):
                if filename.startswith(document_id):
                    return os.path.join(self.base_path, filename)
            
            return None
            
        except Exception as e:
            logger.error(f"❌ Error getting document file path: {e}")
            return None
    
    async def delete_document(self, document_id: str) -> bool:
        """Delete a document"""
        try:
            logger.info(f"🗑️ Deleting document: {document_id}")
            
            file_path = await self.get_document_file_path(document_id)
            if file_path and os.path.exists(file_path):
                os.remove(file_path)
                return True
            
            return False
            
        except Exception as e:
            logger.error(f"❌ Error deleting document: {e}")
            return False
    
    async def get_session_documents(self, session_id: str) -> List[Dict[str, Any]]:
        """Get all documents for a session"""
        try:
            logger.info(f"📄 Getting documents for session: {session_id}")
            
            # This would query the database for session documents
            # For now, return empty list
            return []
            
        except Exception as e:
            logger.error(f"❌ Error getting session documents: {e}")
            return [] 