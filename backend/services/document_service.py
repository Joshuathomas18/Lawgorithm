#!/usr/bin/env python3
"""
Document Service
===============

Service for document generation and export functionality.
"""

import logging
import os
from pathlib import Path
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

class DocumentService:
    def __init__(self):
        self.is_initialized = True
        self.document_base_path = Path("static/documents")
        self.document_base_path.mkdir(parents=True, exist_ok=True)
        
    async def export_document(self, document_text: str, format: str, filename: str) -> Optional[Dict[str, Any]]:
        """Export document to specified format"""
        try:
            logger.info(f"📄 Exporting document as {format}: {filename}")
            
            if format.lower() == 'txt':
                return await self._export_as_text(document_text, filename)
            elif format.lower() == 'pdf':
                return await self._export_as_pdf(document_text, filename)
            elif format.lower() in ['docx', 'doc']:
                return await self._export_as_docx(document_text, filename)
            else:
                logger.error(f"❌ Unsupported format: {format}")
                return None
                
        except Exception as e:
            logger.error(f"❌ Error exporting document: {e}")
            return None
    
    async def _export_as_text(self, document_text: str, filename: str) -> Dict[str, Any]:
        """Export document as plain text"""
        try:
            file_path = self.document_base_path / f"{filename}.txt"
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(document_text)
            
            return {
                'success': True,
                'file_path': str(file_path),
                'download_url': f"/static/documents/{filename}.txt",
                'format': 'txt'
            }
            
        except Exception as e:
            logger.error(f"❌ Error exporting as text: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _export_as_pdf(self, document_text: str, filename: str) -> Dict[str, Any]:
        """Export document as PDF (placeholder - requires PDF library)"""
        try:
            # For now, export as text file with PDF extension
            # In production, you would use a library like reportlab or weasyprint
            file_path = self.document_base_path / f"{filename}.pdf"
            
            # Create a simple text-based PDF placeholder
            pdf_content = f"""
PDF Document Generated by Lawgorithm
=====================================

{document_text}

---
Generated by Lawgorithm Legal AI System
For production use, implement proper PDF generation library.
"""
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(pdf_content)
            
            return {
                'success': True,
                'file_path': str(file_path),
                'download_url': f"/static/documents/{filename}.pdf",
                'format': 'pdf',
                'note': 'PDF generation placeholder - implement proper PDF library for production'
            }
            
        except Exception as e:
            logger.error(f"❌ Error exporting as PDF: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _export_as_docx(self, document_text: str, filename: str) -> Dict[str, Any]:
        """Export document as DOCX (placeholder - requires python-docx)"""
        try:
            # For now, export as text file with DOCX extension
            # In production, you would use python-docx library
            file_path = self.document_base_path / f"{filename}.docx"
            
            docx_content = f"""
DOCX Document Generated by Lawgorithm
=====================================

{document_text}

---
Generated by Lawgorithm Legal AI System
For production use, implement proper DOCX generation using python-docx library.
"""
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(docx_content)
            
            return {
                'success': True,
                'file_path': str(file_path),
                'download_url': f"/static/documents/{filename}.docx",
                'format': 'docx',
                'note': 'DOCX generation placeholder - implement python-docx library for production'
            }
            
        except Exception as e:
            logger.error(f"❌ Error exporting as DOCX: {e}")
            return {'success': False, 'error': str(e)}
    
    async def get_document_info(self, filename: str) -> Optional[Dict[str, Any]]:
        """Get document information"""
        try:
            # Check for file with any extension
            for ext in ['.txt', '.pdf', '.docx']:
                file_path = self.document_base_path / f"{filename}{ext}"
                if file_path.exists():
                    stat = file_path.stat()
                    return {
                        'filename': filename + ext,
                        'file_path': str(file_path),
                        'size': stat.st_size,
                        'created': stat.st_ctime,
                        'modified': stat.st_mtime,
                        'format': ext[1:]  # Remove the dot
                    }
            
            return None
            
        except Exception as e:
            logger.error(f"❌ Error getting document info: {e}")
            return None
    
    async def delete_document(self, filename: str) -> bool:
        """Delete a document"""
        try:
            # Check for file with any extension
            for ext in ['.txt', '.pdf', '.docx']:
                file_path = self.document_base_path / f"{filename}{ext}"
                if file_path.exists():
                    os.remove(file_path)
                    logger.info(f"✅ Deleted document: {filename}{ext}")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"❌ Error deleting document: {e}")
            return False
    
    async def list_documents(self) -> list:
        """List all documents"""
        try:
            documents = []
            for file_path in self.document_base_path.iterdir():
                if file_path.is_file():
                    stat = file_path.stat()
                    documents.append({
                        'filename': file_path.name,
                        'size': stat.st_size,
                        'created': stat.st_ctime,
                        'modified': stat.st_mtime,
                        'download_url': f"/static/documents/{file_path.name}"
                    })
            
            return documents
            
        except Exception as e:
            logger.error(f"❌ Error listing documents: {e}")
            return []
    
    async def health_check(self) -> Dict[str, Any]:
        """Health check for document service"""
        try:
            # Check if document directory is writable
            test_file = self.document_base_path / "test.txt"
            test_file.write_text("test")
            test_file.unlink()
            
            documents = await self.list_documents()
            
            return {
                'status': 'healthy',
                'initialized': self.is_initialized,
                'document_base_path': str(self.document_base_path),
                'writable': True,
                'total_documents': len(documents)
            }
            
        except Exception as e:
            return {
                'status': 'unhealthy',
                'initialized': self.is_initialized,
                'error': str(e),
                'writable': False
            }